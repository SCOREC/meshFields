- User calls parallel_for w/ numitems + 
    each rank dimension

check input index is within range
 -> convert logical indices field(item,d2,d3);

  <double[extent]*, double***>

  parallel_for( item, rankdim... )

  parallel_for( n, 3, 2 );

  n = num_tuples

  slice<1> (double***) -> field(n-3,3,2);
  slice<0> (double[extent]*) -> field(n-3,2);

  solution: Make specific accessors based only on
            the rank of the slice/field.

  *** Only give users access to the logical access operator
      - convert to simd-type stuffs in backend using private
      operators.
  *** Kokkos only use MDRange, Cabana use simd.
      -> possible in future to case analyze
          for nested loops in Kokkos


namespace MeshField:
   MeshField:                
    + SliceController::type  
    - makeField() -> Field<Slice,T>
    - setField() -> void
    - sum() -> FieldType::Type
    - min() -> FieldType::Type
    - max() -> FieldType::Type
    - mean() -> FieldType::Type (double?)
    - parallel_for() -> void
    - parallel_reduce() -> void
    - parallel_scan() -> void
  Field:
    + Slice
    + Slice-type
    - operator()(...) // (up to 5 ranks)
namespace Controller:
  KokkosSliceWrapper<SliceType,T>:
  + SliceType slice
  + T Type
  - operator()(...) -> auto& 
  KokkosController:
    + values_
    + num_tuples
    + indexToSA
    - makeSlice() -> Kokkos::View<Exe,Mem,T>
    - size() -> const int
    - parallel_for() -> void
    - parallel_reduce() -> void
  CabanaSliceWrapper<SliceType,T>
    + SliceType slice
    + T Type
    - operator()(...) -> auto&
  CabanaController:
    + vectorLength
    + aosoa
    + num_tuples
    + indexToSA
    - makeSlice() -> Cabana::Slice
    - size() -> const int
    - parallel_for() -> void
    - parallel_reduce() -> void

field<double*>
KOKKOS_LAMBDA x =( int i ) {
  field(i) -> access(s,a);
  //indextosa based on vectorlength
};

                      -> 0,n-1
parallel_for( n, x );

*** Lambda has to match parallel_for
    compile-time error if field access
    doesnt match rank of field.

IDEA:
KokkosController<MemorySpace,ExecutionSpace, int, double, char> ctrl(20);
                    -> Kokkos::View<int[20]>
                    -> Kokkos::View<double[20]>
                    -> Kokkos::View<char[20]>
so given a type 'Tx', we add a pointer dimension to it:
  int -> int*
  double[5] -> double*[5]
  char[10][20][30] -> char*[10][20][30]
then make that dimension the number of tuples specified to the controller:
  int* -> int[num_tuples]
  double*[5] -> double[num_tuples][5]
  char*[10][20][30] -> char[num_tuples][10][20][30]


// TODO -> Testing suite on the use of std::extent
            in construct_sizes and construct_final_size






